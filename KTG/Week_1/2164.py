# ----------------------------------------------------------------------------------------------------------문제
# N장의 카드가 있다. 
# 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.
# 이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 
# 우선, 제일 위에 있는 카드를 바닥에 버린다.
# 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.
# 예를 들어 N=4인 경우를 생각해 보자. 
# 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 
# 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 
# 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 
# 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.
# N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.

# ------------------------------------------------------------------------------------------------------예제 입력
# 첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.
# 6

# ------------------------------------------------------------------------------------------------------예제 출력
# 첫째 줄에 남게 되는 카드의 번호를 출력한다.
# 4

# --------------------------------------------------------------------------------------------------알고리즘 분류
# 자료 구조
# 큐

# ----------------------------------------------------------------------------------------------------------풀이

# 더 빠른 연산을 위해 collections 모듈에서 deque 를 import
from collections import deque

# 카드 번호 입력
N = int(input())

# 1 ~ N 범위의 deque 를 생성
queue = deque(list(range(1, N+1)))


for i in range(N-1):
    # 맨 앞의 숫자는 pop하여 버리고, 
    queue.popleft()

    # 두번째 숫자를 pop 하여 a 로 저장, 
    a = queue.popleft()

    # queue의 끝에 추가
    queue.append(a)

# queue 에 남은 요소를 index를 이용해 출력
print(queue[0])

# ------------------------------------------------------------------------------------------------------풀이 과정
# 처음에 list의 pop과 insert를 사용하여 문제를 풀었을 때, 시간초과로 실패했었다.
# >>> queue 자료형에 대해 검색한 후, queue 자료형을 만드는 다양한 방법 중 deque 함수를 사용하면 시간복잡도를 개선할 수 있다는 사실을 알게 되었다.

# list 형태의 함수, 특히 pop 과 insert 메서드는 시간복잡도가 O(n) 으로, 시간복잡도가 O(1)인 queue 의 popleft, append 에 비해 매우 길다.
# 참고 링크 : https://chancoding.tistory.com/43