# 1 그리디 알고리즘

미래를 생각하지 않고 각 단계에서 최선의 선택을 하는 기법

**동적 프로그래밍 사용시 일이 많아진다는것을 보완하기 위한 개념**

거스름돈 문제, 큰수의 법칙 문제, 활동 선택 문제, 분할 가능 배낭 문제 등 에서 사용 가능

활동선택문제 예시(ex 1931번)

가장 먼저끝나는 활동들을 골라가는 방식

그리디 알고리즘으로는 정답을 찾기 어려운 경우가 많음 
이런경우 다이나믹프로그래밍이나 그래프 알고리즘을 사용


#2 다이나믹 프로그래밍

한번 계산한 문제를 다시 계산하지 않도록 하는 것

메모리 공간은 조금 더 사용하지만 연산속도가 매우 빨라짐

다이나믹 프로그래밍의 조건
1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

ex) 피보나치 수열
An = A(n-1) + A(n-2), A1 = 1, A2 = 2

- 일반적인 코드

```
def hamsoo(n):
    # 무한대로 초기화된 배열 생성
    dp = [float('inf')] * (n + 1)
    # 처음
    dp[0] = 0
    
    for i in range(2, n + 1):
    # 함수 만들고
    
    return dp[n]
    # 리턴 
```
    

## 메모이제이션

한 번 구한 결과를 메모리 공간에 메모해 두고 같은 식을 호출하면 메모한 결과를 그대로 가져오는 기법

### 탑다운 방식과 바텀업 방식

**탑다운**
큰 문제를 해결하기 위해 작은 문제를 호출하는 하향식 방식
점화식 이해 쉬움
재귀함수로 구현

~~다이나믹프로그래밍과 메모이제이션은 다름
메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓은 넓은 개념을 의미 DP와 별도의 개념~

**바텀업**

작은 문제들부터 답을 구해서 전체 문제의 답을 찾는 상향식 방식
재귀 호출을 하지 않기 때문에 시간과 메모리 사용량을 줄일 수 있음
반복문으로 구현
탑다운보다 바텀업이 권장된다고 함

대표문제로 막대기문제 있음

|표|표|
|---|---|
|길이(i)| 0 1 2 3 4 5 6 7 8 9 10|
|가격(Pi)| 0 1 5 8 9 10 17 17 20 24 30|

길이가 n인 막대기의 최대 가격을 Rn이라고 했을 때, Rn = max(Pi + Rn-i) (i는 1부터 n)로 나타냄
max는 여러 값 중의 최대값을 의미
예를 들면 길이가 4인 막대기의 최대 가격은 R4 = max(P1 + R3, P2 + R2, P3 + R1, P4 + R0)

