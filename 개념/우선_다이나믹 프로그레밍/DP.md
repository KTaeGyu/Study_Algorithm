## 목차

1. 개요
2. DP 사용 조건
3. DP 사용 방법
4. 참조

# Dynamic Programing(DP, 동적 계획법)
## 1. 개요
- DP는 **하나의 큰 문제를 여러 개의 작은 문제로 나누고, 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는** 문제해결의 패러다임이다.<br><br>
- 재귀함수와 다르게 앞서 계산된 값을 다시 반복할 필요가 없으므로, 시간복잡도의 개선이 가능하다.(O(n^2) >> O(f(n)))
## 2. 사용 조건
- **곂치는 부분 문제**
- **최적 부분 구조**
---
### 2-1. 곂치는 부분 문제(Overlapping Subproblems)
- DP를 사용하기 위해서는 동일한 작은 문제(부분 문제)들이 반복하여 나타야 한다.<br>
    <figure>
    <img src="./images/pabonachi.png">
    </figure>
- 예를 들면 위의 파보나치 수열에서, f(2) >> f(1), f(0) 의 구조는 3번 반복 사용되었다. 따라서, 이 값을 미리 저장해 두면 연산 횟수가 확연히 줄어들 것이다.<br><br>
### 2-2. 최적 부분 구조(Optimal Substructure)
- **부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우**를 의미한다.<br>
    <figure>
    <img src="./images/fastroute.png">
    </figure>
- 예를 들어 위의 경우, A에서 X를 거쳐 B로 가는 최단경로를 찾을 때 각각 A에서 X로 가는 경우와 X에서 B로 가는 경우의 최단경로인 AX2와 BX2가 전체 최단경로와 같다.<br><br>
## 3. 사용 방법
#### 1. DP로 풀 수 있는 문제인지 확인(규칙성이 있는지 파악)
- 일정한 패턴이 있는지 즉, 현재 직면한 문제가 작은 문제들로 이루어진 하나의 함수로 표현될 수 있는지에 대한 판단
- 파보나치 수열에서는 **[0, 1, 1, 2, 3, 5, 8, ..., (N-2) + (N-1)]**과 같은 규칙성이 있다.<br><br>
#### 2. 문제의 변수 파악(어디까지 구해야 하는지)
- 일정한 패턴이 있다면, 구해야 하는 변수와 사용할 자릿수를 파악해야 한다.
- 파보나치 수열에서는 **[N번째 숫자]**를 구하기 위해 **[N-1, N-2 번째 숫자]**를 알아야 한다.<br><br>
#### 3. 변수 간 관계식 만들기(점화식 작성)
- 일정한 패턴이 있고 어떤 식으로 어떤 값을 구할 지 결정되었다면, 점화식으로 이를 표현해야 한다.
- 파보나치 수열에서는 **[f(n) = f(n-1) + f(n-2)]**와 같이 점화식을 세울 수 있다.<br><br>
#### 4. 메모하기(기억할 공간 할당)
- 위 점화식을 통해 값을 구할 때, 이전 값을 이용하기 위해서 이를 저장할 공간이 필요하다.
- 파보나치 수열에서는 f(n)을 구하기 위해 f(n-1), f(n-2)를 저장할 공간이 필요하다. 즉, 총 **[N + 1개의 공간]**이 필요하다.
#### 5. 기저 상태 파악하기
- 뒷 상태를 연산하기 위해 필요한 가장 낮은 상태를 알아야 한다.
- 파보나치 수열에서는 **[f(0)와 f(1)]**에 대해 알아야 작성이 가능하다.<br><br>
#### 6. 구현하기(2가지 방식)
1. Bottom-up(Tabulation 방식) : 반복문 사용
    - dp[0] 부터 시작해서 값을 저장해 나가며 dp[N]을 구하는 방식
        ```python
        N = int(input()) # 문제의 변수
        dp = [0] * (N + 1)  # 메모하기
        dp[0], dp[1] = 0, 1  # 기저상태

        for i in range(2, N+1):
            dp[i] = dp[i-1] + dp[i-2]  # 규칙성, 점화식
        
        print(dp[N])
        ```
2. Top-Down(Memoization 방식) : 재귀 사용
    - dp[N]을 호출하여 기저상태인 dp[0]까지 내려간 다음 결과값을 재귀를 통해 전이시키는 방식
        ```python
        def fibonacci(N):
            if N == 0:
                return 0  # 기저상태 1
            elif N == 1:
                return 1  # 기저상태 2
            else:
                return fibonacci(N-1) + fibonacci(N-2)  # 규칙성, 점화식
        
        N = int(input())  # 문제의 변수
        print(fibonacci(N))
        ```
## 4. 참조
- 두 가지 방법 중 어느 것이 더 효율적인지는 문제마다 다르기 때문에 알 수 없다. 또한 둘 중 한가지 방법만 사용해서 풀 수 있는 문제도 있다. 그러므로, 두 방식 모두 알아두는 것이 좋다.
- Divide and Conquer(분할 정복)
    - 주어진 문제를 작게 쪼개서 하위 문제로 해결하고 연계적으로 큰 문제를 해결한다는 점에서 같다.
    - 그러나, 분할 정복은 분할된 하위 문제가 동일하게 중복이 일어나지 않는 경우에 쓰인다는 차이점이 있다.
    - ex: 병합정렬