# 동적 계획법(= Dynamic Programming)

- DP의 핵심은 큰 문제에서 생기는 작은 문제들을 중복없이 풀고, 각각의 값을 table에 저장해서 큰 문제의 값을 찾을 때, 작은 문제의 값들은 table에서 가져와서 쓰는 기법이다.
- 작은 문제의 값을 여러번 계산할 필요가 없으므로, 쓸데 없는 계산을 최대한 줄여 시간을 짧게 만들 수 있다.
- 작은 부분 문제들을 모두 해결한 후 → 그 해들을 이용하여 큰 부분의 문제들을 해결 → 원래 주어진 문제를 해결하는 방식
- 가장 많이 언급되는 예시로 `피보나치 수열`이 있다.
  
## DP의 두가지 접근방식
1. Top - down 방식 
    - 큰 문제 → 작은 문제
    - F(6)을 구하기 위해서 F(5), F(4), ... , F(1), F(0)까지 재귀 알고리즘을 이용하여 구함
    - 즉, F(6)을 구하기 위해서는 앞에서 구한 값들을 저장해 놔야하고, 그것을 저장하기 위해 Memoization 방식을 이용한다. 
    - Memoization: 앞에서 해결된 문제들을 저장해놨다가 필요할 때마다 꺼내 쓰는 것
2. Bottom - Up 방식
    - 작은 문제 → 큰 문제
    - F(6)을 구하기 위해 F(0), F(1), ... , F(6) 차례대로 문제를 해결


## 예시1. 피보나치수열
$a_n = a_{n-1} + a_{n-2}$  
$a_1 = a_2 = 1$

예를 들어, 피보나치 수열의 $a_4$를 구할려면 $a_4 = a_3 + a_2$를 구해야하고, 여기서 $a_3$은 한번 더 피보나치 수열의 식을 이용해서 $a_3 = a_2 + a_1$를 이용해서 구할 수 있다.  
숫자가 커질수록 계산의 양이 많아지는데, 이를 DP방식을 이용해서 구하면 각각의 $a_n$의 값을 기억해 놨다가 꺼내 쓰는 방식이므로 조금 더 줄일 수 있다.
```python
def fibo(n):
    if n <= 2:
        return 1
    return fibo(n - 1) + fibo(n - 2)
```
다음과 같이 재귀함수를 이용해서 계산하면 n = 5일 때를 구한다고 했을 때,   
$a_5 = a_4 + a_3$이고, $a_4 = a_3 + a_2$와 $a_3 = a_2 + a_1$를 이용해서 구하는데   
여기서 위의 재귀함수를 이용한다면 $a_3$을 두번 계산하게 된다.  
이러한 계산 낭비를 줄이기 위해 DP를 이용한다.
### 1. Top - down 방식을 이용
```python
n = int(input())
DP = [0] * (n + 1)     # 0 ~ n의 n + 1개 리스트 

def fibo(n, DP):
    if n <= 1:  # 만약 n이 0, 1이면 각각 0, 1을 출력해 재귀적인 계산 종료 
        return n

    if DP[n] != 0: # 이미 n번째가 계산되어 있다면?
        return DP[n] # 있는거 가져와라
    
    DP[n] = fibo(n - 1, DP) + fibo(n - 2, DP)  # 그리고 계산
    return DP[n]

print(f'{n}항의 피보나치 수열 값은 {fibo(n, DP)}입니다.')
```
### 2. Bottom - Up 방식
```python
def fibo(n):
    if n <= 1:
        return n # 얘는 종료 조건
    
    DP = [0] * (n + 1) # 얘는 DP가 함수 정의 안에 위치함
    DP[1] = 1   # 초기화용 
    # DP[0]은 이미 0이라 필요없음

    for i in range(2, n + 1):
        DP[i] = DP[i - 1] + DP[i - 2]

    return DP[n]

n = int(input())
print(f'{n}항의 피보나치 수열 값은 {fibo(n)}입니다.')
```
### 3. 코드에서 두 방식의 차이
- Top - Down방식은 DP리스트를 함수정의 밖에 박아두고 계속 업데이트하면서 함수 굴릴때마다 DP리스트에서 뽑아 쓰는 방식
- Bottom - Up방식은 DP리스트를 함수 정의 안에 둬서 함수를 굴리면서 밑에서 부터 채워가는 방식



## 예시2. [1로 만들기(백준 1463번)](./1로만들기.py)
```
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
- X가 3으로 나누어 떨어지면, 3으로 나눈다.
- X가 2로 나누어 떨어지면, 2로 나눈다.
- 1을 뺀다.
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
```
5는 5 -> 4 -> 2 -> 1 `3번`  
6은 6 -> 3 -> 1 `2번`  
7은 7 -> 6 -> 3 -> 1 `3번`  
...  
10은 10 -> 5 -> 4 -> 2 -> 1 4번 / 10 -> 9 -> 3 -> 1 `3번`  
   

위의 예시를 통해
- 숫자가 2나 3으로 나눠진다면 나눴을 때의 몫을 넣어서 그 때의 값 +1
- 나눠지지 않는다면 1을 빼서 구한 후 그 때의 값 +1

코드로 나타내면 다음과 같다.
```python
def min_operations_to_one(N):
    DP = [0] * (N + 1)
    
    for i in range(2, N + 1):
        DP[i] = DP[i - 1] + 1   # 우선 n의 횟수를 (n - 1의 횟수 + 1)로 둔 다음에
        if i % 2 == 0:      # 만약에 2로 나눠진다면
            DP[i] = min(DP[i], DP[i // 2] + 1)      # 2로 나눴을 때의 몫의 횟수 + 1과 앞의 값과 비교해서 min값
        if i % 3 == 0: # 3으로 나눠진다면
            DP[i] = min(DP[i], DP[i // 3] + 1)      # 앞에서 update했거나, 그대로 둔 값과 비교해서 작은값
    
    return DP[N]

N = int(input())
result = min_operations_to_one(N)
print(result)
```
## 예시3. [설탕배달](./설탕배달.py)
- 주어진 무게에서 3이나 5로 나눠서 최대한 전체 몫이 작게 나오게
- 점화식: dp[i] = min(dp[i - 3] + 1, dp[i - 5] + 1)
  
```python
def sugar_delivery(N):
    # dp[i]: i 킬로그램을 배달하기 위해 필요한 최소 봉지 개수
    dp = [float('inf')] * (N + 1)
    dp[0] = 0                       # 초기값 설정
    
    for i in range(3, N + 1):           
        dp[i] = min(dp[i], dp[i - 3] + 1)
    
    for i in range(5, N + 1):
        dp[i] = min(dp[i], dp[i - 5] + 1)
    
    return dp[N] if dp[N] != float('inf') else -1

# 입력 받기
N = int(input())
result = sugar_delivery(N)
print(result)

```